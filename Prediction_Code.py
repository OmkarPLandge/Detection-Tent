# -*- coding: utf-8 -*-
"""Execution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wpDA5bFyNltycUU0clUlbWzpGem81w61
"""


import numpy as np
import tensorflow as tf
import matplotlib
import PIL
import imagecodecs
import tifffile
import rasterio
import geopandas as gpd
import shapely
import matplotlib.pyplot as plt
import tifffile as tiff
from rasterio.windows import Window
from rasterio.features import shapes
from shapely.geometry import shape


# List of modules to check
modules = [np, tf, matplotlib, PIL, imagecodecs, tifffile, rasterio, gpd, shapely]

# Print versions
for module in modules:
    try:
        print(f"{module.__name__} version: {module.__version__}")
    except AttributeError:
        print(f"{module.__name__} does not have a version attribute")

# Additionally, to print the Python version
import sys
print(f"Python version: {sys.version}")



#sliding window approach for prediction
non_boundary_pixels =6467441
boundary_pixels =86159

total_pixels = (boundary_pixels + non_boundary_pixels)
boundary_weight = (total_pixels / boundary_pixels) * 0.7
non_boundary_weight = (total_pixels / non_boundary_pixels) * 0.3
class_weights = [non_boundary_weight, boundary_weight]
def weighted_binary_crossentropy(non_boundary_weight, boundary_weight):
    def loss(y_true, y_pred):
        b_ce = tf.keras.backend.binary_crossentropy(y_true, y_pred)
        weight_vector = y_true * boundary_weight + (1. - y_true) * non_boundary_weight
        weighted_b_ce = weight_vector * b_ce
        return tf.keras.backend.mean(weighted_b_ce)
    return loss

loss_function = weighted_binary_crossentropy(non_boundary_weight, boundary_weight)

# Load the model
RESUnet_model = tf.keras.models.load_model(r"H:\MMC_Client\RoofTop_Detection\Training\Laptop\RESUNet_128size_50Epochs_BFD.hdf5",custom_objects={'loss': loss_function})

# Input and output paths
input_image_path = r"H:\MMC_Client\RoofTop_Detection\Training\NewAOI\Three_Bnads_Aoi.tif"
output_image_path = r"H:\MMC_Client\RoofTop_Detection\Training\Laptop\Prediction_Image.tiff"
output_shapefile_path = "H:\MMC_Client\RoofTop_Detection\Training\Laptop\Prediction_Image.shp"

def mask_to_geojson(mask, transform):
    """Convert binary mask to GeoJSON-like feature."""
    polygons = []
    for geom, value in shapes(mask.astype('int16'), transform=transform):
        if value == 1:
            polygons.append(shape(geom))
    return polygons

def predict_image(RESUnet_model, input_image_path, output_path1, output_shapefile_path, target_size=(128,128), threshold=0.2, stride=64):
    with rasterio.open(input_image_path) as src:
        img_shape = src.shape
        transform_affine = src.transform

        # Calculate the number of patches needed
        rows = (img_shape[0] - target_size[0]) // stride + 1
        cols = (img_shape[1] - target_size[1]) // stride + 1

        # Initialize an array to store the predicted masks
        predicted_masks = np.zeros(img_shape, dtype=np.uint8)

        # Iterate over each patch
        for r in range(rows):
            for c in range(cols):
                window = Window(c * stride, r * stride, target_size[1], target_size[0])
                img_patch = src.read(window=window)

                # Normalize pixel values
                img_patch = img_patch / np.max(img_patch)

                # Transpose the input patch to match the expected input shape of the model
                img_patch_transposed = np.transpose(img_patch, (1, 2, 0))

                # Perform inference
                prediction_resunet = RESUnet_model.predict(np.expand_dims(img_patch_transposed, axis=0))

                # Ensure the prediction has the correct datatype and shape
                prediction_resunet = np.squeeze(prediction_resunet, axis=0)  # Remove the batch dimension

                # Apply threshold to convert probabilities to binary values
                binary_mask = (prediction_resunet > threshold).astype(np.uint8)

                # Remove the unnecessary channel dimension from the binary mask
                binary_mask = np.squeeze(binary_mask, axis=-1)

                # Place the predicted patch into the correct position in the output array
                predicted_masks[r * stride:r * stride + target_size[0], c * stride:c * stride + target_size[1]] = binary_mask

    # Save the binary mask as an image with the original shape and resolution using tiff.imwrite
    with rasterio.open(output_path1, 'w', driver='GTiff', height=img_shape[0], width=img_shape[1], count=1, dtype=np.uint8, crs=src.crs, transform=transform_affine) as dst:
        dst.write(predicted_masks, 1)

    # Convert the binary mask to GeoJSON-like feature
    polygons = mask_to_geojson(predicted_masks.astype('int16'), transform_affine)

    # Create a GeoDataFrame with the polygons
    #bbox = box(0, 0, img_shape[1], img_shape[0])  # Create a bounding box
    gdf = gpd.GeoDataFrame(geometry=polygons, crs=src.crs)  # Set the coordinate reference system

    # Save the GeoDataFrame to a shapefile
    gdf.to_file(output_shapefile_path, driver='ESRI Shapefile')


# Make prediction
predict_image(RESUnet_model, input_image_path, output_image_path, output_shapefile_path)

# Plot the input image and output
fig, axes = plt.subplots(1, 2, figsize=(15, 5))

input_img = imagecodecs.imread(input_image_path)
output_img = tiff.imread(output_image_path)

# Display the input image as RGB
axes[0].imshow(input_img, aspect='auto')  # Display all three bands
axes[0].set_title("Input Image")  # Adjust the title accordingly
axes[0].axis('off')

axes[1].imshow(output_img, cmap='gray', aspect='auto')  # Assuming the output is binary
axes[1].set_title("Output Image")
axes[1].axis('off')

plt.tight_layout()
plt.show()


